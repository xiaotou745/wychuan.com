@{
    ViewBag.Title = "主页";
    Layout = "/Views/Shared/_LayoutOfAticle.cshtml";
}

问题来了，程序中明明Mike的sex是Male，Lucy是Female，却出现了上面图片中“诡异”的的现象，这当然是线程安全问题！来分析一下：

在上一篇博文Java多线程技术学习笔记（一）中分析了线程安全问题产生的原因：

多个线程操作共享的数据
操作共享数据的线程代码有多条
回头看我们的代码，共享数据Person r被两个线程操作，满足第一条；操作 r 的代码就是run方法里面的代码，看到第36行开始的run方法确实有很多条，满足第二个条件！所以出现上述诡异输出其实是很正常的现象！具体到上述代码，造成原因：

假设线程0即Input线程，首先抢到cpu执行权，由于x==0, 那么Person对象r的name就是Mike, sex就是Male, 然后x = (x + 1)%2 = 1.
接着有可能Input线程继续占有着cpu执行权， 由于39行的while（true）和x == 1,执行到48行,这时 r 的name = Lucy,问题来了，Input线程还没有来得及更新r的sex，即还没有来得及执行第49行代码，这时线程1，Output线程把cpu执行抢走了。
于是此时r的name就是Lucy，而sex由于没来得及改变还是Male，然后Output线程输出：Lucy...Male! 产生Mike...Female的过程与此类似!
分析了原因，就来解决问题，那就是前一篇博文笔记里面说的同步：

 View Code
多次运行之后可以验证，输出正常:



但是注意到，输出是连续一堆Lucy...Female,然后连续一堆Mike...Male,原因很简单：一旦切换到输出线程，该线程不可能只执行一次，一下输出多次，因为name 和 sex 由于同步的缘故，要么是Lucy...Female，要么是Mike...Male，一输出就是一片相同的Lucy或者Mike. 为了展示多线程间的通信，现在要实现的是，输入线程输入一个name和sex，就立马在输出线程输出，然后再输入一个，再输出一个，如此交替！注意输入和输出是在不同线程里面执行的！所以就需要线程间通信，即输入线程输了一个name和sex,就不在继续输入，而是去通知输出线程输出一下刚才输入的name和sex，输出一次之后，也不再继续输出，而是去通知输入线程继续输入新的内容，输入线程和输出线程如此交替... 这就是所谓的“等待唤醒机制”。

二、等待唤醒机制 返目录回

要达到上面所说的输入和输出线程交替执行，需要设置一个标志位，根据标志位来判断到底是该执行输出还是输出！

涉及的方法：

wait():让线程处于冻结状态，被wait的线程会被存储到线程池，所有等待的线程都在这个池子里面，等待机会去执行。该方法是从java.lang.Object继承过来的：
　　翻译过来意思就是：该方法会导致当前线程等待，直到其他线程调用了此线程的notify或者notifyAll方法。 注意到wait方法会抛出异常，所以在面我们的代码中加入了try/catch

nofity()：唤醒线程池中任意一个线程。
notifyAll()：唤醒线程池中的所有线程。
